# Next steps

[x] Fill in class definitions + serialize, create instances for single workspace data
    [x] HyperText
        [x] also implement serialize, make app print stringified store
        [x] create HyperJSON interface
        [x] create an object-based instance of HyperText
        [x] render hypertext
            [x] clarify types for serialized objects
            [x] factor out dispatch and hypertext components
            [x] add to fixtures for cases below
            [x] implement hypertext rendering
                [x] strings
                [x] arrays
                [x] nodes
                [x] arrays with nodes
                [x] workspace template object
            [x] split hypertext.tsx into multiple files
    [x] Clean up, commit
    [x] Node + NodeVersion
        [x] add simple fixtures
        [x] add classes
        [x] render node version, making use of hypertext render
            - don't render included nodes (since we don't know what version to render)
            - but we do need to render hypertext
              - this mean that we need to retrieve it
              - this can be analogous to how graphql works later
                - (then, we do one big query at the top, and little cached queries while rendering)
        [x] extract classes from fixtures
    [x] Workspace + WorkspaceVersion + Link
        [x] add basic workspace / workspace version / link fixtures
        [x] write corresponding classes
        [x] write components that render these classes
            [x] Render workspace version
                [x] Render link
                [x] HyperText should take prop that determines how included nodes are rendered
                [x] Build renderNode function
            [x] Render links without context
            [x] Render workspace
            [x] Render node
            [x] Clean up
                [-] fixme: renderNode returns a Link...
                    - This may be fine for now
                [x] Clean up WorkspaceVersion code
                [x] Should renderNode be curried so that we don't have to pass store everywhere?
                    - both NodeVersion and Link need access to the store, so I don't think that would owrk
                [x] Should renderNode take renderNode as an argument?
                    - no, since WorkspaceVersion can't be used recursively within itself
                [x] if one "workspace" is included in another workspace, which renderNode
                    should we use?
                    - we want outer workspace's expansion status
                    - but for versions, it's less clear
                      - i think there is a coherent version where we only look at outer
                        workspace's versions (and latest version)
                      - in this case, outer workspace's renderNode should be used
                    - This will happen automatically, since inclusion doesn't work by
                      including the "Workspace" component
                [x] Fix overlapping names: workspace (the template) vs workspace (the data model and wrapper)
                    - we will never include the data model component within itself                          
[x] Rendering the latest version of everything in a workspace
    [x] think about how to do this correctly
        - options
          - make a version of renderNode that just gets the latest version?
          - retrieve the latest version for every link ahead of time
            - this requires recursion, since pointed-to nodes might include further nodes
            - but should be only one step (in addition to first step required for snapshot/consistent), since
              things can't be expanded if we haven't seen them
            - this seems better - we create a version of renderNode by first loading the
              latest version ahead of time
            - we'll need to assert that we actually don't need to do recursive fetching;
              there's a runtime assumption here that included nodes will never be expanded
              by default
    [x] create fixtures that test rendering latest version vs current snapshot or consistent version
        - I created a new version of the question node
    [x] allow selecction in workspace renderer of which version is being rendered
        [x] fixme: need to refactor - split up responsibility for retrieving latest nodes
            between workspace and workspace version
            - we need to know the latest expansion status, so we need to retrieve
              the latest set of links, which makes sense to do in WorkspaceVersion
    [x] take useLatestNodeVersions into account in WorkspaceVersion:
        implement fastForwardLinkValues
        - Do we need to add links for new included nodes that are not expanded?
          - Can we just assume that everythink that's linked is expanded, and expanding a pointer adds a link?
    [x] get rid of isExpanded status, track via presence/absence of link
[x] Add a fixture that tests pointers that aren't expanded
[x] Plan what to work on next
    [x] Look over operations for breaking down questions - for each, think about how I'd implement it
[x] Think about (but don't implement):
    [x] where and how we'd compute and indicate staleness
    [x] budgets
    [x] caching
    [x] Look over notes, think about any implications for next steps
        - Main implication is probably that immutable-js + redux should be more likely
        - (Maybe not immutable, maybe just redux?)
[x] Add a workspace route/view
    [x] Add react-router
    [x] Link to workspace page from front page
    [x] Display workspace on workspace page
[ ] Try workspace with sub-workspaces (via child q&a)
[ ] Look into switching store to redux (maybe +immutable-js)
[ ] Add functionality
    [ ] Expanding a pointer
    [ ] Basic export/edit functionality
    [ ] Creating a child workspace
    [ ] Creating a pointer
    [ ] Different stackings of exports and imports
[ ] Clean up fixtures (bundle)
[ ] Integration with slate editor

Later:
[ ] Use redux or apollo
[ ] Caching node ids for hypertext (when we're using server)
[ ] Make it easy to create root questions with data
[ ] A workspace template included in another workspace template
[ ] Caching
[ ] Computing what's stale
[ ] Budgets
[ ] Choosing a workspace to show next

Maybe:
[ ] Rename head to snapshot
[ ] Split hypertext into two representations, array-ref hypertext and associated node ids


--------------------------------------------------------------------
Future features

# Indicating staleness

Stale => we can't rely on it anymore
Example: the answer to a question is stale if the question changed

- For each node version that we're importing (reading):
  - If there is a newer version of the node, it is stale
  - If there is no newer version of this node:
    - We find the workspace that exports (writes) it, and look at the nodes this workspace imports (which we can read off from the links)
    - If any of them have changed (i.e. there are new node versions) since the last consistent version of the workspace, the node is stale as well
      - So, a case where the node isn't stale is when other exports have changed in the source workspace,
        including the scratchpad and sub-questions and values of other exported pointers

Where does this computation happen?
- Maybe in WorkspaceVersion (or wherever we factor out the WorkspaceVersion computations to)
  - renderNode would render stale nodes differently, could show a diff


# Budgets

Should budgets be a property of node values?

- One option is to simply store them as part of the question-answer-templated hypertext
  - This would naturally mark nodes as stale when budgets change
  - They could also be imported + expanded instead of stored directly
  - In this case, we'd also associate the workspace node id with the list of children,
    and the transfer would simultaneously make new versions of our workspace node and
    the child

- Another option would be to make budgets a property of WorkspaceVersion
  - At a minimum, we'd create a new workspace version snapshot at the end of an episode
  - Transferring part of the budget to another workspace version makes new versions of both,
    and maybe creates a BalanceTransaction
  - At the moment, we're not tracking parent/child workspaces though; this only implicitly
    happens through included questions/answers
  - This would require special code for tracking staleness due to budgets

- Yet another option would be to store budgets with root node links
  - When the budget changes, we make a new version of the link(s)
  - This seems less intuitive

We'll want to access budgets on the server, since this is part of what goes into the
process for selecting which workspace to show next.

On the other hand, we might want all kinds of information to go into that process, including
the content of workspaces.

My guess for now is that budgets should be part of hypertext (solution #2), but it doesn't seem
quite right and if budgets are treated as imports, this would probably mark everything as stale,
even when it shouldn't.
- There are two kinds of budget we're talking about here:
  1. The budget the parent assigned to us. If that increases, we *should* mark the answer as stale.
  2. The budget we have left, which goes down as we use up more. If this changes, we *shouldn't* mark anything as stale.
     - This is more like an export
     - There could be a special link, "budgetUsed", which tracks how much budget we've used
     - Or this could be a property of the workspace version (we make a new version at the end of every episode)
       - This (together with the info from our parent) controls how much budget we can assign to children

New guess:
- The budget assigned to us can just be part of the question hypertext.
  If it changes, the exports from our workspace are marked as stale.
  We can use a particular template structure for the question hypertext.
- The budget we have used up so far. This can be part of the workspace version.
- When we create a child, we need to specify a budget, which requires us to look at our current workspace version and the question.
- This doesn't feel very clean; feels like things should either happen entirely on a workspace version level or
  on a hypertext level, but might still be the best local solution (since using up budgets is different from specifying budgets
  with respect to implications for staleness)


# Caching

- For caching, we need a content-based hash of the state of a workspace, and we need to store pairs of (workspace-hash, action)
- Caching should happen on the server
- For the content-based hash of the workspace, we basically want the information computed in WorkspaceVersion, retrieve the
  corresponding node versions, and normalize the visible pointer representation
  - It could be desirable to do all of this computation in WorkspaceVersion / ahead of time, to store the state in redux, and
    to just pass an immutable js object down the tree
- Actions are more complex. But we'll have to encode those somehow anyway, maybe as redux store actions. The main additional
  thing that's required for caching to work is to also normalize (and denormalize) the pointer representations here.
  I.e. each action talks about operations on node 1, 2, ..., but that gets converted to operations on the underlying nodes.
  It's possible that this will get tricky for operations that create new pointers.

My guess:
- Create an immutable-js(-like) representation of everything that's rendered on the current screen, so that we have a coherent
  representation of the workspace state
- Make sure that pointer references are normalized with respect to the current workspace, starting at 1
  (possibly using names, in which case it would be city-1, city-2, etc)
- Use redux actions for all changes, and express these changes in terms of the normalized pointer references
- Record pairs of (immutable-workspace-state, redux-action)
- When actions are executed, denormalize the pointer references

If budgets are part of the state representation, we might need to use approximate caching pretty much immediately, since
budgets will very infrequently be exactly the same.


# Choosing a workspace to show next

This is a server-side computation.

Initially, we could just show a workspaced at random, and allow users to skip.

A bit later, we might want a user-independent priority computation.

Eventually, we want to compute user-specific predictions for what to show.

We might also look into showing two workspace, and let the user choose which one to work on.

The information that we'll want to use to compute what to show probably includes the state representation we want for caching.
For deciding what to show, budgets matter a lot; for caching, budgets matter a little.
Another diffference is that for deciding what to show, we might want to do more graph-based computation.
For example, we might want to find the leaves, get those to be consistent, and then propagate up.
(This might be like belief propagation in Bayesian networks. Maybe there are sub-trees or clusters of nodes that we can make consistent first, and then use the results in the remainder without worrying about the subtree again.)


--------------------------------------------------------------------
Operations

- Edit the answer, which will be visible to the parent.
  * we make a new version of that node, and update head for that node
  * optionally we save a new consistent workspace
  * if the parent views the latest (fast-forwarded) version of the workspace, they will see our new answer

- Edit the scratchpad text
  * same as editing the answer

- Add a sub-workspace (without pointers) with a question that you created
  * create all the data structures
  * add links for question (write) and answer (read)
  * create new version of current workspace

- Delete (archive) a sub-workspace
  * set a field in the "children" hypertext structure
    (we might want to introduce some abstractions, and do fromJSON and toJSON)

- Edit the question for a sub-workspace
  * same as editing the answer in a sub-workspace

- Create a pointer
  * create hypertext, node, nodeversion; update including node version / hypertext to refer to node; add write link to workspace
  * // there are a bunch of operations here, might want to test this
  
- Add a pointer (that we created) to a sub-workspace question
  * we simply add { nodeId: ... } to the question hypertext, make a new node version
  
- Remove a pointer (that we created) from a sub-workspace question
  * we remove the { nodeId: ... } from question hypertext, make a new node version
  * this doesn't automatically remove the corresponding link from the sub-workspace
  * the sub-workspace might have used the link in their scratchpad
  * for now i'd leave it up to workspace editors to remove those refs
  * but eventually we might want a differnt solution

- Delete a pointer (that we created) and didn't pass on
  * things this could mean:
    * delete the pointer use in a node/block. this is the same as making other edits to a node
    * remove the exporting link. we can do this, and then we lose ability to make edits.
      maybe there should be a sequence of operations (1) replace pointer content with "deleted", (2) remove link
  
- Delete a pointer (that we created) and did pass on
  * same as above

- Pass a pointer from our question to a sub-workspace question
  * we just include { node: nodeId } in the hypertext for a sub-workspace question
  * initially this won't be expanded for the sub-workspace
  
- Pass a pointer from an answer to a sub-workspace question in our reply to the parent
  * we just include { node: nodeId } in the hypertext for the answer
  * initially this won't be expanded for the parent workspace

- Expand (unlock) a pointer passed in from the parent (without it being expanded in other workspaces that may use it)
  * add a link for the pointer('s current node version)

- Expand (unlock) a pointer passed in from an answer
  * add a link for the pointer('s current node version)

- Expand (unlock) a pointer within an already expanded pointer
  * add a link for the pointer('s current node version)
  
- Close (lock) a previously purchased pointer
  * remove a link

- Edit the text behind a pointer we own / created
  * make a new version of the node
  * optionally, save workspace snapshot
  
- Create a nested pointer ourselves
  * this is a sequence of operations
  * creating the inner nested pointer works the same way as creating the first workspace-level pointer, only with respect to a different node
  * in both cases, we add a link to the current workspace

- Create a nested pointer from a plain-text list of items
  * this would be a bunch of machinery to create a sequence of pointers
  * if we can create a single pointer automatically, we can also do this

- Edit the text in a nested pointer we created ourselves
  * same as editing a non-nested block; the main (big) challenge here is to get the ui working

- Create a nested pointer using a pointer we got from a parent
  * we simply include { nodeId: x } for the right node id
  
- Expand multiple levels of a nested pointer we got from a parent or child
  * same as expanding a single level step by step

Probably:
- Create a pointer directly when editing a sub-workspace question or the answer
  * same as making pointers elsewhere
- Directly point to the question/answer for each sub-workspace
  * same as pointing to other nodes (but need ui)
